import{Q as s}from"./QBtn-DKy_yooC.js";import{T as n,E as d}from"./TextHeader2-TQiaOL02.js";import{T as p,a}from"./TextBody1-BPCkxQmK.js";import{d as c,r as m,a as f,f as y,b as e,w as t,F as g,e as l,j as o,_ as h}from"./index-DHLu7VNo.js";import"./QCard-e3BSHyBw.js";import"./QScrollObserver-C9H9M275.js";import"./PlayGround-DJiHJlkP.js";const _=o("ul",null,[o("li",null,"Compile-time type system, with generics and global type inference supported"),o("li",null,"Ad-hoc polymorphism that can be user-defined through something like traits of Rust"),o("li",null,"Primitive types include Int, Float, Bool and Str. Operations on them are provided."),o("li",null,"Algebraic data types, and pattern matching on them"),o("li",null,"Module system to organize code into many files"),o("li",null,"Partial application"),o("li",null,"Closure. both anonymous closures and recursives closures are supported."),o("li",null,"Mutability of local variables and IO in an impure function"),o("li",null," Simple compile-time optimizations including inlining, dead code elimination, constant propagation, common expression elimination, control flow graph simplication and tail-call optimiztion "),o("li",null,"Compiles to a kind of byte-code executed by the Helo VM"),o("li",null,"Mark-and-sweep garbage collector")],-1),b=c({__name:"RefIntroduction",setup(w){const i=m(`routine main = io.println "Hello World!"
`);return(x,r)=>(f(),y(g,null,[e(p,null,{default:t(()=>[l("Introduction")]),_:1}),e(a,null,{default:t(()=>[l(" Helo Lang is my toy language that I built out of interest. It draws inspiration from Rust and Ocaml. Of course, as a toy, it can be packed full of bugs, not to mention its not-user-friendly error messages. Most likely, even myself won't apply it in any pratical applications. ")]),_:1}),e(n,null,{default:t(()=>[l("Features")]),_:1}),e(a,null,{default:t(()=>[l(" Helo Lang was originall built to be a strict-evaluated functional language. To support IO, I took the shortest path of introducing impure functions called routines, compared with Haskell's way, since I was discouraged by the complexity of a type system that supports higher ranked types. Also, currying is not supported, as implementing only partial application is much easier. ")]),_:1}),e(a,null,{default:t(()=>[l(" Following list highlights major features of Helo. ")]),_:1}),e(a,null,{default:t(()=>[_]),_:1}),e(n,null,{default:t(()=>[l("Hello World")]),_:1}),e(a,null,{default:t(()=>[l(" Helo compiler and runtime has been compiled to Web Assembly, so it can run directly in browser, just like below. ")]),_:1}),e(d,{modelValue:i.value,"onUpdate:modelValue":r[0]||(r[0]=u=>i.value=u),height:200,"initial-split":50},null,8,["modelValue"]),e(n,null,{default:t(()=>[l("Examples")]),_:1}),e(a,null,{default:t(()=>[l(" The playground contains some examples of Helo code, for example, an "),e(s,{color:"primary",flat:"",dense:"","no-caps":"",to:"/playground/AVLTree"},{default:t(()=>[l("AVL Tree")]),_:1}),l(" and a "),e(s,{color:"primary",flat:"",dense:"","no-caps":"",to:"/playground/Calculator"},{default:t(()=>[l("Calculator")]),_:1}),l(". ")]),_:1})],64))}}),A=h(b,[["__file","RefIntroduction.vue"]]);export{A as default};
