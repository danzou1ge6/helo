import{T as o,a as s}from"./TextBody1-Cc3uXhbj.js";import{d as r,a as c,f as l,b as e,w as t,j as i,E as n,F as d,e as a,_ as u}from"./index-mfOJ6gAK.js";const h="/helo/assets/Arch-_TsZmLMW.svg",m=["data"],f=r({__name:"RefArchitecture",setup(p){return(_,b)=>(c(),l(d,null,[e(o,null,{default:t(()=>[a("Architecture")]),_:1}),e(s,null,{default:t(()=>[a(" This section briefly describes the architecture of Helo compiler and runtime. The following graph illustrates the passes for compiling source code to byte code. ")]),_:1}),i("object",{data:n(h),type:"image/svg+xml",class:"q-pa-md"},null,8,m),e(s,null,{default:t(()=>[a(" Then, the compiled byte code is ran by a Register-based virtual machine. This is very simple virtual machine that runs a big switch-case loop, A mark-and-sweep garbage collector is also part of the virtual machine. As few as possible lines of unsafe code is employed in the VM. Most of them are introduced to implement garbage collector and objects managed by the GC. The VM itself contains no unsafe code. ")]),_:1})],64))}}),y=u(f,[["__file","RefArchitecture.vue"]]);export{y as default};
